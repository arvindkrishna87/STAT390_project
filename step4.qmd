---
title: "Step 4: Patching"
editor: 
  markdown: 
    wrap: 72
--- 


**Aim:.** To determine whether a fixed patch size can be used effectively for patching. We propose running a patching algorithm on one stain and analysing the distribution of patches it generates. If a large majority of the patches are a specific size, that size can be considered the optimal. Since the distribution of patches will be the same across stains, the optimal patch size found can be used across all three stains.

![](images/Step4.png){fig-align="center"}

## Pathologist Team Step

We will send matched and extracted epithelium slices
to the pathologist team to annotate the regions.

![](images/Annotations.png){fig-align="center"}

While they annotate the regions, we're working on our patching algorithms.

# Aryaman's Patching Algorithm: Methodology


The **rotation patching code** processes stained tissue images by aligning them spatially, segmenting key regions (epithelium and stroma), and extracting patches for comparative analysis across different stains (H&E, Melan-A, and Sox-10). The algorithm creates a skeleton by converting the image of the epithelium mask into a binary format, reducing the tissue to a central line. The skeleton represents the centreline through the epithelial region, and is used as a guide for placing patches. At each point on the skeleton, the algorithm calculates the slope between neighbouring points, which defines the orientation of the patch. Using this orientation, it forms a square patch which aligns with the boundary. The patch is kept only if it includes regions from the stroma and the background, ensuring that the full width of the epithelium is captured in most cases. Overlapping patches are removed in the final step.

![](images/mask_and_skeleton.png){fig-align="center"}

Follow this step-by-step manual to patch the epithelia.

:::{.callout-note collapse=true}

## Step-by-Step Manual

Code required:

- rotate_extract_patch (1).py

Run `rotate_extract_patch (1).py`.

:::

# Results

**Orientation**

![](images/Orient.png){fig-align="center"}

![](images/Step4.png){fig-align="center"}

## Comparing Approaches

### Alyssa's Code

| Pros              | Cons              |
|------------------|-----------------|
| Patches grow until they cover a sufficient region of the epithelium, which allows for better adaptability across different epithelium widths <br><br> This also allows for some overlap between patches, which helps create a balance for ensuring coverage and not missing any key spots without too much duplication. | This method incrementally increases patches using very small step sizes, making code time consuming (likely why this algorithm does not work as effectively with larger, thicker tissues (e.g. the large Copenhagen slices)) <br><br> This algorithm also depends on color thresholds to identify tissue regions, which may lead to inconsistencies or require frequent adjustments due to variations. <br>-For example, the black and white mask isolates the epithelium from the stroma and background. 
 <br>-Stain type/image quality/lighting could affect which part is labeled as epithelium vs. stroma vs. background, which could then lead to melanocytes being cut out/not captured in patches. <br><br> Differences in color characteristics, staining protocols, lighting, or image quality could create challenges for reliable application. <br><br> The portion of the algorithm that checks for overlap rejects new patches if there is more than 20% overlap with an existing patch. This percentage could be harder to maintain in narrow regions with smaller patches and/or anywhere small overlaps might be unavoidable for complete coverage.|

### Aryaman's Code

| Pros              | Cons              |
|------------------|-----------------|
| - Advantage 1<br>- Advantage 2 | - Disadvantage 1<br>- Disadvantage 2 |

### Eli's Code

| Pros              | Cons              |
|------------------|-----------------|
| - Advantage 1<br>- Advantage 2 | - Disadvantage 1<br>- Disadvantage 2 |


## Tilting the patches

Tilting of patches could lead to smaller, more efficient patches. Smaller patches are advantageous because we will get more data to work with. Each patch will also have less data in it, and our model may have an easier time picking up on patterns. Also, tilting the patches, means that the epithelium is always in the same orientation in each patch. Our model will not have to determine the orientation of a sample. Perhaps, this will lead to a simpler, more efficient model. 

### Aryaman’s algorithm

We use edge detection and find the slope between two points on the edge. Using that slope, we create one edge of the square. This way, the square is tilted to match up with the angle of the sample. \n
<br>
**Upsides:** There is already code for that edge detection and finding the edge of the square. \n
<br>
**Downsides:** The samples are very irregular, so, when the edge is extended, a patch could cut off a lot of epithelium. That cut off epithelium could then be picked up by other patches, but there might be inefficiency in the patching this way. Also, see downsides of Aryaman’s whole algorithm. 

### Different tilting algorithm: 

We pick a random patch. Next, we identify the stroma and the outside of the sample. We treat the pixels of the stroma and the outside of the sample as points. Using these points, we run a regression model to draw the line that most efficiently crosses the epithelium. Now, we will tilt the patch so that two edges are perpendicular and two edges are parallel to that regression line. This will create a patch that follows the contour of the epithelium. Below is a visual representation of this process.

![](images/regression_tilt.png){fig-align="center" width=70%}

**Upsides:** this method is not very computationally expensive, especially with the epithelium mask that we have for each sample already. \n
<br>
**Downsides:** When tilting an existing patch, we cannot ensure that the patch still includes the entire epithelium unless we also resize the patch. \n
<br>
**Note:** This separates the tilting from the patching process. While this is not necessarily a negative, we don’t know which patching algorithm works best with this method yet. It adds another step to the process.





