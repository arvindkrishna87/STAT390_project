---
title: "Step 4: Patching"
editor: 
  markdown: 
    wrap: 72
--- 
This step is happening in tandem with Step 3 (slice annotation)

**Aim:** To determine whether a fixed patch size can be used effectively for patching. We propose running a patching algorithm on one stain and analysing the distribution of patches it generates. If a large majority of the patches are a specific size, that size can be considered the optimal. Since the distribution of patches will be the same across stains, the optimal patch size found can be used across all three stains.

## Patching Questions

1. How many distinct patch sizes should we consider? Should we fit patches on every tissue slice to visualise the distribution? <br>
2. Does having more patches make the ML model more complex? Consequently, shold we try to minimize the number of distint patch sizes we use? <br>
3. If adaptive pooling can be used effectively to handle images of different sizes (i.e. handle distinct patch sizes) can a ML model distinctly identify patterns in small patches or large patches?

# Aryaman's Patching Algorithm: Methodology

The **rotation patching code** processes stained tissue images by aligning them spatially and extracting patches for comparative analysis across different stains (H&E, Melan-A, and Sox-10). The algorithm creates a skeleton by converting the image of the epithelium mask into a binary format, reducing the tissue to a central line. The skeleton represents the centreline through the epithelial region, and is used as a guide for placing patches. At each point on the skeleton, the algorithm calculates the slope between neighbouring points, which defines the orientation of the patch. Using this orientation, it forms a square patch which aligns with the boundary. The patch is kept only if it includes regions from the stroma and the background, ensuring that the full width of the epithelium is captured in most cases. Overlapping patches are removed in the final step.

![](images/mask_and_skeleton.png){fig-align="center"}

Follow this step-by-step manual to patch the epithelia.

:::{.callout-note collapse=true}

## Step-by-Step Manual

Code required:

- rotate_extract_patch (1).py

Run `rotate_extract_patch (1).py`.

:::

## Results

![](images/Step4.png){fig-align="center"}

# Comparing Approaches

## Alyssa's Code

| Pros              | Cons              |
|------------------|-----------------|
| Patches grow until they cover a sufficient region of the epithelium, which allows for better adaptability across different epithelium widths <br><br> This also allows for some overlap between patches, which helps create a balance for ensuring coverage and not missing any key spots without too much duplication. | This method incrementally increases patches using very small step sizes, making code time consuming (likely why this algorithm does not work as effectively with larger, thicker tissues (e.g. the large Copenhagen slices)) <br><br> This algorithm also depends on color thresholds to identify tissue regions, which may lead to inconsistencies or require frequent adjustments due to variations. <br>- For example, the black and white mask isolates the epithelium from the stroma and background. <br> - Stain type/image quality/lighting could affect which part is labeled as epithelium vs. stroma vs. background, which could then lead to melanocytes being cut out/not captured in patches. <br><br> Differences in color characteristics, staining protocols, lighting, or image quality could create challenges for reliable application. <br><br> The portion of the algorithm that checks for overlap rejects new patches if there is more than 20% overlap with an existing patch. This percentage could be harder to maintain in narrow regions with smaller patches and/or anywhere small overlaps might be unavoidable for complete coverage.|

## Aryaman's Code

| Pros              | Cons              |
|------------------|-----------------|
| The patch will be generated from the points along the centerline, ensuring that the epithelium is well-positioned within the square patch. Patches are aligned perpendicular to the skeleton, capturing the structural direction of the epithelium. <br><br> Consistency across patches since the points are always centralized within the epithelial region. <br><br> Patch dimensions can be customized to increase the chances of covering the entire epithelium in a single patch. <br><br> | Calculating skeletons, determining gradients, and filtering patches for overlap can be computationally intensive, especially for large images. Code checking if the patch contains both stroma and epithelium is also time consuming. <br><br> The patch size is fixed, and the algorithm samples along the skeleton at intervals, potentially missing parts of the epithelium in patches. The fixed patch size may not be optimal for varying epithelial dimensions. If a specific epithelial region is wider than the patch width, the algorithm may fail to capture it entirely in a single patch. Since the algorithm discards patches that do not include stroma, epithelium, and background, there is a risk that such regions might be missed entirely. <br><br> Skeletonization errors (e.g., gaps or noisy lines) could result in incomplete or misaligned patches.  |

## Eli's Code

| Pros              | Cons              |
|------------------|-----------------|
| - Advantage 1<br>- Advantage 2 | - Disadvantage 1<br>- Disadvantage 2 |


# Tilting the patches

Tilting of patches could lead to smaller, more efficient patches. Smaller patches are advantageous because we will get more data to work with. Each patch will also have less data in it, and our model may have an easier time picking up on patterns. Also, tilting the patches, means that the epithelium is always in the same orientation in each patch. Our model will not have to determine the orientation of a sample. Perhaps, this will lead to a simpler, more efficient model. 

## Aryaman’s algorithm

We use edge detection and find the slope between two points on the edge. Using that slope, we create one edge of the square. This way, the square is tilted to match up with the angle of the sample. \n
<br>
**Upsides:** There is already code for that edge detection and finding the edge of the square. \n
<br>
**Downsides:** The samples are very irregular, so, when the edge is extended, a patch could cut off a lot of epithelium. That cut off epithelium could then be picked up by other patches, but there might be inefficiency in the patching this way. Also, see downsides of Aryaman’s whole algorithm. 

## Alyssa’s algorithm

Patches grow incrementally until they cover a sufficient region of the epithelium, allowing the algorithm to adapt better to varying epithelium widths. The method also permits some overlap between patches, striking a balance between thorough coverage and avoiding excessive duplication. \n
<br>
**Upsides:** This adaptability across different epithelium widths improves coverage, and the overlap between patches helps ensure no critical regions are missed while avoiding excessive redundancy. \n
<br>
**Downsides:** Small step sizes can computationally expensive, particularly when dealing with larger tissues, such as the Copenhagen dataset with single large slices per stain. The algorithm’s reliance on color thresholds to identify tissue regions can lead to inconsistencies or require frequent adjustments due to variations in stain type, image quality, or lighting. 

![](images/alyssa_ex1.png){fig-align="center"}

## Different tilting algorithm: 

We pick a random patch. Next, we identify the stroma and the outside of the sample. We treat the pixels of the stroma and the outside of the sample as points. Using these points, we run a regression model to draw the line that most efficiently crosses the epithelium. Now, we will tilt the patch so that two edges are perpendicular and two edges are parallel to that regression line. This will create a patch that follows the contour of the epithelium. Below is a visual representation of this process.

![](images/regression_tilt.png){fig-align="center" width=70%}

**Upsides:** this method is not very computationally expensive, especially with the epithelium mask that we have for each sample already. \n
<br>
**Downsides:** When tilting an existing patch, we cannot ensure that the patch still includes the entire epithelium unless we also resize the patch. \n
<br>
**Note:** This separates the tilting from the patching process. While this is not necessarily a negative, we don’t know which patching algorithm works best with this method yet. It adds another step to the process.

## Patch Design and Optimization QnA

### Question 1: Why are square patches used in tissue analysis?

Square images are commonly used in tissue image analysis as they naturally fit into the grid-like structure of digital images, making it easier for algorithms to scan and analyze oatterbs, They streamline calculations for convolutional neural networks (CNNs), which process grids of data efficiently. This uniformity ensures all parts of an image are treated equally, avoiding distortions or biases that could arise from irregular shapes, i.e. rectangular patches. Additionally, square patches align with pre-trained models, saving time and effort by leveraging existing resources. They also simplify techniques like pooling, which reduces data size while preserving important features, focusing on key details without unnecessary complexity. Overall, they offer a balance of computational efficiency and accuracy.

### Question 2: Why is patch size in powers of 2? (e.g. 32 x 32, 256 x 256, 512 x 512, etc.) Are there alternatives?

CNN layers benefit from power-of -2 to maintain spatial coherence and compatibility with pooling and downsampling operations. Non-standard dimensions risk spatial distortion or mismatched sizes. GPU’s are optimized for power-of-2 memory alignment, with non-standard dimensions causing potential performance drops, though modern GPUs handle them better. Internal resizing of images wastes memory, processing time, and could introduce rounding errors. Non-standard sizes may also require extra padding to ensure compatibility with layer operations. The 224x224 image size standard introduced in AlexNet, set a precedent for future architectures. Nvidia Tensor Cores optimize hardware efficiency with batch sizes in multiples of 8, while unrelated, it shows how aligning dimensions with hardware multiples improves efficiency.

### Question 3: How do researchers determine the optimal number of patches?

The number of patches depends on the variety in the images and the difficulty of identifying differences in the classes. Too many patches can lead to over-segmentation and loss of context. Additionally, it increases the computational cost. Too few patches would make it hard for the model to generalize to unseen data. If we can determine the optimal patch size, that can determine the optimal number of patches by managing the overlap. 


